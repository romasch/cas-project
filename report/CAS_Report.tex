\documentclass[11pt, a4paper,oneside,chapterprefix=false]{scrbook}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}

\usepackage{a4wide}
\usepackage{times}
\usepackage{helvet}   % sets sans serif font

\usepackage{amsmath,amssymb,amsthm}

\usepackage{graphicx}
\usepackage{subfigure}  
\usepackage{fancybox} % for shadowed or double bordered boxes
\usepackage{fancyhdr}

\DeclareGraphicsExtensions{.pdf, .jpg}

%% macros
\input{include/math}
\input{include/codelisting_layout}

\usepackage{color}
\definecolor{RED}{rgb}{1,0,0}
\definecolor{GREEN}{rgb}{0,0.7,0}
\definecolor{BLUE}{rgb}{0,0,1}
\newcommand{\FIXME}[1]{{\color{RED}{\textbf{FIX}: #1}}}

\addtolength{\textheight}{2.0cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textwidth}{1.8cm}
\addtolength{\hoffset}{-.9cm}

\widowpenalty=10000
\clubpenalty=10000

%\author{Hans Muster}
%\title{Blockwise Hierarchical Data Decompositions}
%\date{Fall Semester 2011}

\begin{document}

\frontmatter
%\maketitle %automatic version
% --- selfmade version ----
\begin{titlepage}
	\setlength{\parindent}{0cm}
	\addtolength{\textheight}{1.0cm}
	\vspace{0.5cm}
	\sffamily\Huge
	{\textbf {CAS Report \\ A comparison of neo4j and postgres}}

	\vfill \vfill \vfill

	\vfill
	\textsf\Large
	CAS Data Science and Machine Learning \\[0.5cm]\large
	21.06.2022\\[0.5cm]
	\large
	by Roman Schmocker, Ergon Informatik AG

	\vfill \vfill \vfill
	\begin{minipage}[b]{0.5\textwidth}
	Supervisors: \\
	Prof. Dr. Sven Helmer
	\end{minipage}
	%
	\begin{minipage}[b]{0.5\textwidth} \raggedleft
	Department of Informatics \\
	University of Zurich
	\end{minipage}

	\vfill
	\hrule
	\vspace{0.5cm}
	\includegraphics*[width=0.3\textwidth]{figures/uzh_logo} \hfill
%	\includegraphics*[width=0.3\textwidth]{figures/vmml_logo}
\end{titlepage}
%%


%=====================================================================
\chapter{Abstract} \label{chp:abstract}
%=====================================================================


{\em Keywords}: TODO

\tableofcontents

\mainmatter

%=====================================================================
\chapter{Introduction} \label{chp:introduction}
%=====================================================================

Over many years the default for data storage was a relational database, and it still is today. 
However, in recent years the NoSQL Movement has gained traction.
NoSQL is actually an umbrella term for many different technologies.
Among them are graph databases.
Graph database optimize graph traversal and path finding and other stuff.
In this report, we want to look at a specific graph database Neo4j and compare it to Postgres, a popular free relational DB.

[TODO maybe also tell why neo4j might be used in our company]

%=====================================================================
\chapter{Database comparison (neo4j vs postgres)} \label{chp:theory}
%=====================================================================

On the relational side we have Postgres, a very classical relational database.
The underlying theory is relational algebra [link to paper].
Data is stored in tables with a strict schema.
The data can be queried using SQL.

Neo4j is a free graph database with commercial support.
Internally all data is stored as a labelled property graph.
Meaning there are nodes with properties, as well as edges with properties.
Internally, neo4j uses the index-free adjacency technique, a storage technique which allows to traverse a graph without looking up nodes in an index.
This is in contrast to relational database where foreign key relations have to be resolved by loading the specific entry from another table through an index.
The data in neo4j is queried through Cypher query language, an SQL like language specifically desigend for graphs.
It allows to match agains graph relations with the --> operator.

%=====================================================================
\chapter{Methods} \label{chp:methods}
%=====================================================================


%---------------------------------------------------------------------
\section{The ICIJ offshoreleaks data set} \label{sec:dataset}
%---------------------------------------------------------------------

The data used for the comparison is from the ICIJ offshoreleaks [link].
The consortium provides the database as a dump, and thus it can be directly imported to neo4j.

For postgres we use the export as CSV function.
This returns the data as one big table, which we can import using the postgres `COPY` statement to a temporary table.
Since nodes and edges are mixed using this technique, we further copy the data along with the relevant properties into a `node` and an `edge` table.
There are no further tables based on type because we want the flexibility of traversing the graph regardless of labels.
(On production systems we may want to have different tables per label or relationship type).

%---------------------------------------------------------------------
\section{Queries} \label{sec:benchmark}
%---------------------------------------------------------------------

For our comparison we select four queries as in \cite{graphdbbenchmark}.
They used a simple point query to fetch just a single result, a one-hop and two-hop query to traverse along one or two edges respectively, and a shortest path query.
Additionally, we add a sligthly more complex query to match a subgraph pattern.
Note that queries focus a lot on graph traversal and give an advantage to neo4j.
This is kind of fine, because we consider a scenario where a graph database is used in addition to a relational database.

\subsection{Point Query}

The point query is a very simple lookup by name.
There is no edge traversal necessary and therefore no joins as well in the relational database.

\subsection{One-Hop Query}

This query will search for a specific node and return this node as well as all directly adjacent nodes.

\subsection{Two-Hop Query}

Similar to the one-hop query, but we go one step further and return the neighbours of neighbours.
It is not a fully transitive fetch, we stop at depth two.

\subsection{Shortest Path}

Find the shortest path between two nodes, if they are connected at all. E.g. to find out if Marc Rich (former founder of Glencore and always a bit in trouble with the law) still has connections to the Glencore group.

\includegraphics*[width=0.5\textwidth]{figures/query_shortest_path.png} \hfill

\subsection{Subgraph Matching}

We want to find two different officers for the same firm who live at the same address, e.g. to find family relations.
This targets the subgraph matching [link?] aspect of graph databases.

\includegraphics*[width=0.5\textwidth]{figures/query_relation.png} \hfill


% \subsection{Transitive Query}
%
% Transitively find all nodes reachable from a start node, maybe up to some level X. E.g. find all entities that are directed by the king of Saudi Arabia [TODO: maybe find a better example]
%
% \includegraphics*[width=0.5\textwidth]{figures/query_transitive.png} \hfill


%---------------------------------------------------------------------
\section{Measurements} \label{sec:measurements}
%---------------------------------------------------------------------

For performance measurements, we repeat a sample queries a number of times and measure average response time and standard deviation.
The simple queries are repeated 100 times.
The input for these queries varies each time with a different node to look for.
The shortest path and subgraph matching was repeated only 10 times with fixed input.
The measurement was done with Neo4J 4.4 and Postgres 14.3, each running in a Docker container.
The host system has an Intel Core i9-9900K CPU with 3.60GHz and 64GB RAM.

%=====================================================================
\chapter{Results} \label{chp:results}
%=====================================================================

%---------------------------------------------------------------------
\section{Performance} \label{sec:performance}
%---------------------------------------------------------------------

The result of the query performance is shown in table \ref{table:performance}:

\begin{table}
	\begin{center}
		\begin{tabular}{ |l|c|c|c| }
			\hline
			& no. of queries & neo4j & postgres \\
			\hline
			Point Query & 100 & 0.044 $\pm$ 0.023 & 0.044 $\pm$ 0.001 \\
			One-Hop & 100 & 0.039 $\pm$ 0.016 & 0.121 $\pm$ 0.006 \\
			Two-Hop & 100 & 0.037 $\pm$ 0.018 & 0.275 $\pm$ 0.008 \\
			Shortest Path & 10 & 2.532 $\pm$ 0.035 & 16.414 $\pm$ 0.239 \\
			Subgraph Matching & 10 & 5.522 $\pm$ 0.155 & 28.174 $\pm$ 0.179 \\
			\hline
		\end{tabular}
		\caption{\label{table:performance} Query exeuction time in seconds (mean $\pm$ standard deviation).}
	\end{center}
\end{table}

Generally, Cypher outperforms Postgres by a factor 3 to 7 in all but the simple point query.

There were also some problems in Shortest Path to make it even remotely usable, e.g. Postgres materializes the with query (https://www.postgresql.org/docs/current/queries-with.html). Any where clause therefore needs to be pushed into the recursive query.
Another problem is that the intermediate result set gets too big if the distinct clause is not present (doubly calculated work).

%---------------------------------------------------------------------
\section{Ease of use} \label{sec:convenience}
%---------------------------------------------------------------------

Neo4j has a graph traversal operator $\rightarrow$ which can be used to search adjacent nodes.
This is a very powerful tool, as every such graph traversal needs to be modeled as two joins in the relational model.
The effect of this can be seen very nicely in the two-hop query, which requires four joins in Postgres:

\lstinputlisting[language=SQL,label=two-hop-query]{pseudocode/two-hop.txt}

Another very useful, although somewhat situational query mechanism is the shortest\_path funciton in Cypher.
It can be used to find connections between two nodes very easily and efficiently.
In Postgres we have to implement a kind of breadth-first search with a recursive common table expression and stop when the target node has been found.

\lstinputlisting[language=SQL,label=shortest-path-query]{pseudocode/shortest-path.txt}

This example also shows how Cypher can easily ignore the directionality of edges
if we do not specify the arrowhead in the $\rightarrow$ operator.
To achieve the same behavior in Postgres we need to first calculate the union of the regular and reversed 'edge' table.

TODO: maybe measure complexity somehow (num characters, num operators)?

%=====================================================================
\chapter{Discussion} \label{chp:discussion}
%=====================================================================

The result heavily favors neo4j, but this is expected since we chose queries where a graph DB is traditionally strong.
However, the result also shows that it is possible to use a relational database.
Whether to use neo4j or not (in addition to a relational DB) therefore very much depends on the requirements.
If there are many queries for subgraph matching or transitive graph traversal are required, the query improvements might outweigh the additional complexity and potential data duplication of having two database systems.

%=====================================================================
\chapter{Conclusion and future work} \label{chp:conclusion}
%=====================================================================

In this report we have analyzed three queries in neo4j and postgres and compared their execution performance and query complexity. 
Due to the design of the study, the result favors neo4j, but it depends on the requirements if neo4j should be used.
Note that this study does not try to answer the question if neo4j can be used instead of postgres, only if it can be used in addition to postgres. The former was never a goal.

We believe this resolves all remaining questions on this topic. No further research is needed. [https://xkcd.com/2268/]


\bibliographystyle{alpha}
\bibliography{references}
\end{document}
