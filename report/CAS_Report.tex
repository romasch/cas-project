\documentclass[11pt, a4paper,oneside,chapterprefix=false]{scrbook}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}

\usepackage{a4wide}
\usepackage{times}
\usepackage{helvet}   % sets sans serif font

\usepackage{amsmath,amssymb,amsthm}

\usepackage{graphicx}
\usepackage{subfigure}  
\usepackage{fancybox} % for shadowed or double bordered boxes
\usepackage{fancyhdr}
\usepackage{float}

\DeclareGraphicsExtensions{.pdf, .jpg}

%% macros
\input{include/math}
\input{include/codelisting_layout}

\usepackage{color}
\definecolor{RED}{rgb}{1,0,0}
\definecolor{GREEN}{rgb}{0,0.7,0}
\definecolor{BLUE}{rgb}{0,0,1}
\newcommand{\FIXME}[1]{{\color{RED}{\textbf{FIX}: #1}}}

\addtolength{\textheight}{2.0cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textwidth}{1.8cm}
\addtolength{\hoffset}{-.9cm}

\widowpenalty=10000
\clubpenalty=10000

%\author{Hans Muster}
%\title{Blockwise Hierarchical Data Decompositions}
%\date{Fall Semester 2011}

\begin{document}

\frontmatter
%\maketitle %automatic version
% --- selfmade version ----
\begin{titlepage}
	\setlength{\parindent}{0cm}
	\addtolength{\textheight}{1.0cm}
	\vspace{0.5cm}
	\sffamily\Huge
	{\textbf {CAS Report \\ A comparison of neo4j and postgres}}

	\vfill \vfill \vfill

	\vfill
	\textsf\Large
	CAS Data Science and Machine Learning \\[0.5cm]\large
	21.06.2022\\[0.5cm]
	\large
	by Roman Schmocker, Ergon Informatik AG

	\vfill \vfill \vfill
	\begin{minipage}[b]{0.5\textwidth}
	Supervisors: \\
	Prof. Dr. Sven Helmer
	\end{minipage}
	%
	\begin{minipage}[b]{0.5\textwidth} \raggedleft
	Department of Informatics \\
	University of Zurich
	\end{minipage}

	\vfill
	\hrule
	\vspace{0.5cm}
	\includegraphics*[width=0.3\textwidth]{figures/uzh_logo} \hfill
%	\includegraphics*[width=0.3\textwidth]{figures/vmml_logo}
\end{titlepage}
%%


%=====================================================================
\chapter{Abstract} \label{chp:abstract}
%=====================================================================


{\em Keywords}: TODO

\tableofcontents

\mainmatter

%=====================================================================
\chapter{Introduction} \label{chp:introduction}
%=====================================================================

Relational databases have been around for many years now and form a cornerstone of most modern IT applications.
In recent years however, NoSQL databases have gained more widespread use.
NoSQL databases renounce the table model and the underlying relational algebra of traditional database systems and instead provide alternative data storage solutions, each specialized to a specific task.

Graph databases are one such type of NoSQL databases.
They internally model all data as a graph, and as such are optimized towards graph traversal, path finding and visualizing relationships within graph structures.

As such, a graph database might be an ideal addition for the software project that we are working on at Ergon Informatik AG.
In this project we build a dossier management system for public prosecutors and the police.
A graph database could for example be used to visualize relations between different persons or to track the various paths that money has been paid to during a money laundering scheme.

In this report we will therefore try to compare and find advantages of a graph database against relational databases.
We will pick PostgreSQL as a relational database, because it is a popular database that is already in use within our project.
For the graph database, we will use Neo4j - mostly because there are datasets readily available for our analysis.
As we already use PostgreSQL in our project, the goal of this analysis is not to decide whether to use one database system or the other, but rather to find out whether it is worthwile to add Neo4j in addition to PostgreSQL.
Therefore, all of the queries we analyze specifically target a scenario where the underlying model is already a graph, as we would otherwise simply use the already present PostgreSQL database.

%=====================================================================
\chapter{Database Systems} \label{chp:theory}
%=====================================================================

\section{PostgreSQL}
PostgreSQL \cite{postgres} is an open source that has been in development since 1996.
Its theoretical foundation is relational algebra \cite{relationalalgebra} and therefore represents a typical relational database system.
Data is stored in multiple tables which can reference each other by foreign key relations.
As opposed to most NoSQL solutions, there is a strict schema that data needs to conform to.
The data can be queried using the SQL query language.

\section{Neo4j}
Neo4j \cite{neo4j} is an open source graph database system with commercial support.
It has been in development since 2007.
As a graph database, Neo4j stores all its data as a labelled property graph - a graph composed of nodes and edges which both can have an arbitrary number of named properties.
Additionally, both nodes and edges can have a type (or label) which can be used to classify nodes and impose a semi-structured schema on the node regarding its properties.

For efficient graph traversal, Neo4j uses index-free adjacency internally \cite{neo4jinaction:chapter11}.
Index-free adjacency is a graph storage technique which allows to follow along graph edges simply by looking up a pointer in memory.
This is different from a relational database where a foreign key relation needs to be resolved by looking up the physical address of another entry via a database index and then loading the corresponding page table entry to memory in a second step.

The data in neo4j is queried through Cypher query language, an SQL like language specifically desigend for graphs.
One of the main features of Cypher is the $(a)\rightarrow(b)$ operator, which is used to match two nodes a and b connected by an edge.

%=====================================================================
\chapter{Data and Benchmark Queries} \label{chp:methods}
%=====================================================================


%---------------------------------------------------------------------
\section{The ICIJ offshoreleaks data set} \label{sec:dataset}
%---------------------------------------------------------------------

The dataset used for the comparison is from the ICIJ offshore leaks \cite{offshoreleaks}.
The ICIJ consortium provides the database as a dump file, and thus it can be directly imported to Neo4j.
The dataset is basically a huge graph which shows connections between letterbox companies (Entities) with their addresses, their board of owners and directors (Officers) as well as any intermediaries that provide legal services. In total the graph contains about  1.97 million nodes and 3.27 million edges.

To get the same dataset into Postgres we used the ``Export as CSV'' function in Neo4J and then imported the resulting file into a temporary Postgres table using the \lstinline{COPY} statement.
As nodes and edges are mixed into a single table using this technique, we further copy the data into a \lstinline{node} and an \lstinline{edge} table with proper foreign key relations in between.
The type and labelled properties of the graph are mapped to individual columns in the database table.

Although it is possible to further partition the \lstinline{node} and \lstinline{edge} tables based on their labels, we decided against it to keep the flexibility of traversing the whole graph in SQL.

%---------------------------------------------------------------------
\section{Queries} \label{sec:benchmark}
%---------------------------------------------------------------------

For our comparison we select four queries as in \cite{graphdbbenchmark}.
In their paper they analyzed a simple point query to fetch just a single result, a one-hop and two-hop query to traverse along one or two edges respectively, and a shortest path query.
In addition to that we also add a slightly more complex query which is aimed towards finding a subgraph pattern within the whole graph.

Please note that - with the exception of the point query - all of our queries require some kind of graph traversal.
This kind of study design of course heavily works in favor of Neo4j.
But as we already mentioned, the idea is to identify scenarios where a graph database is vastly superior to a relational database such that the integration of a second database management system might be justified.

\subsection{Point Query}

The point query is just a simple lookup of a graph node by its name property.
There should be no edge traversal necessary and therefore also no join in a relational database.

\subsection{One-Hop Query}

The one-hop query will search for a specific node by its name with any neighbors. It should return the found node, as well as all directly adjacent nodes.

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query-one-hop.png}
\end{center}



\subsection{Two-Hop Query}

The two-hop query is similar to the one-hop query, but it will also look for ``neighbors of neighbors'' of the start node and return them. It is not a fully transitive fetch operation, because the query will only look at adjacent nodes up to a level of two.

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query-two-hop.png}
\end{center}

\subsection{Shortest Path}

The goal is to find the shortest path between two nodes, or if they are connected at all. In our example we want to find out if Marc Rich, the founder of Glencore who was later convicted for tax evasion and several other crimes, still has ties to the Glencore group.

\begin{center}

\includegraphics*[width=0.5\textwidth]{figures/query-shortest-path-2.png}
\end{center}


\subsection{Subgraph Matching}

We want to find two different officers for the same company who live at the same address.
Such queries can for example be used to find family relations.
We use this query because it is designed to find specific patterns (subgraphs) within a whole graph.

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query_relation.png}
\end{center}



% \subsection{Transitive Query}
%
% Transitively find all nodes reachable from a start node, maybe up to some level X. E.g. find all entities that are directed by the king of Saudi Arabia [TODO: maybe find a better example]
%
% \includegraphics*[width=0.5\textwidth]{figures/query_transitive.png} \hfill


%---------------------------------------------------------------------
% \section{Measurements} \label{sec:measurements}
%---------------------------------------------------------------------



%=====================================================================
\chapter{Results} \label{chp:results}
%=====================================================================

\section{Performance}

For performance measurements, we repeatedly ran the above queries and measure average response time and standard deviation.
The simple queries are repeated 100 times.
The input for these queries varies each time with a different node to look for.
The shortest path and subgraph matching was repeated only 10 times with fixed input.
The measurement was done with Neo4J 4.4 and PostgreSQL 14.3, each running in a Docker container.
The host system has an Intel Core i9-9900K CPU with 3.60GHz and 64GB RAM.
The result of the measurements is shown in table \ref{table:performance}.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ |l|c|c|c| }
			\hline
			& no. of queries & neo4j & postgres \\
			\hline
			Point Query & 100 & 0.044 $\pm$ 0.023 & 0.044 $\pm$ 0.001 \\
			One-Hop & 100 & 0.039 $\pm$ 0.016 & 0.121 $\pm$ 0.006 \\
			Two-Hop & 100 & 0.037 $\pm$ 0.018 & 0.275 $\pm$ 0.008 \\
			Shortest Path & 10 & 2.532 $\pm$ 0.035 & 16.414 $\pm$ 0.239 \\
			Subgraph Matching & 10 & 5.522 $\pm$ 0.155 & 28.174 $\pm$ 0.179 \\
			\hline
		\end{tabular}
		\caption{\label{table:performance} Query exeuction time in seconds (mean $\pm$ standard deviation).}
	\end{center}
\end{table}

\section{Query complexity}

The following sections provide a side-by-side comparison of Cypher and SQL queries.

\subsection{Point Query} \label{sec:result:point}
\lstinputlisting[language=SQL,label=point-query]{pseudocode/point-query.txt}

\subsection{One-Hop Query}\label{sec:result:one-hop}
\lstinputlisting[language=SQL,label=one-hop-query]{pseudocode/one-hop.txt}

\subsection{Two-Hop Query} \label{sec:result:two-hop}
\lstinputlisting[language=SQL,label=two-hop-query]{pseudocode/two-hop.txt}

\subsection{Shortest Path} \label{sec:result:shortest-path}
\lstinputlisting[language=SQL,label=shortest-path-query]{pseudocode/shortest-path.txt}

\subsection{Subgraph Matching} \label{sec:result:subgraph-matching}
\lstinputlisting[language=SQL,label=subgraph-matching-query]{pseudocode/subgraph.txt}




%=====================================================================
\chapter{Discussion} \label{chp:discussion}
%=====================================================================

\section{Performance}

Generally Neo4J performs better than PostgreSQL by a factor 3 to 7 in all but the simple point query.
This might be explained by the index-free adjacency that Neo4j internally uses for efficient graph traversal.

Most of the queries performed reasonably well with the first implementation in both Cypher and SQL, but the shortest path query required a few optimizations to get it to run below one minute. For example, Postgres always materializes a common table expression and does not push predicates into the CTE itself \cite{postgresMaterialize}.
Therefore it is imperative that the \lstinline{where} clause which selects the start node is within the recursive common table expression itself, or else PostgreSQL will happily calculate the shortest path from every node to every other node at once.
Another problem was that there can be multiple paths with the same length between two different nodes, and PostgreSQL would continue the search from both paths, leading to a lot of duplicate work. A \lstinline{select distinct on} operator can solve this problem however.
Both of these optimizations can be seen in the code listing in section \ref{sec:result:shortest-path}

Even with all these optimizations, Neo4j significantly outperforms PostgreSQL for shortest path calculations.
One possible explanation is that the former can apply specialized algorithms like Djikstra \cite{dijkstra} which are not easily possible in plain SQL. Neo4j can also abort the query as soon as a viable solution has been found, whereas PostgreSQL will first fully evaluate its common table expression and only then select the shortest path.

%---------------------------------------------------------------------
\section{Ease of use} \label{sec:convenience}
%---------------------------------------------------------------------

The graph traversal operator $\rightarrow$ offered by Neo4j is very powerful for reducing query complexity.
To achieve something similar in Postgres, every graph ``hop'' needs to be modeled as two joins between the node and edge tables. The effect of this can be seen nicely in the two-hop query code in \ref{sec:result:two-hop}, which is only two $\rightarrow$ operators in Cypher but requires four joins in SQL. The net result is three lines of code for Cypher and almost 8 lines of code to achieve the same in SQL

Another useful query mechanism is the built-in \lstinline{shortest_path()} function in Cypher.
It is used to find connections between two nodes efficiently and with little write overhead.
To achieve the same functionality in in PostgreSQL we have to implement a kind of breadth-first search with a recursive common table expression and stop when the target node has been found.
The algorithm to perform this in SQL is shown in section \ref{sec:result:shortest-path}.
Here the difference in number of lines of code between Cypher and SQL is even worse - there are only 5 lines of Cypher code but 28 lines of SQL code to calculate the shortest path between two nodes.

This example also shows how Cypher can optionally ignore the directionality of edges.
If we do not specify an arrowhead in the $\rightarrow$, Neo4j will just use any edge from or to a node to calculate the shortest path.
To achieve the same behavior in PostgreSQL we need to first calculate a union of the normal and reversed \lstinline{edge} table.

Finally, in the last listing in section \ref{sec:result:subgraph-matching} we can see the full power of the graph traversal operator. In the form \lstinline{(a:Officer) -[:officer_of]-> (entity:Entity)} it will match against a node of type \lstinline{Officer} with an \lstinline{officer_of} edge towards an \lstinline{Entity} node. An equivalent operation in SQL requires two joins and three \lstinline{WHERE} conditions.

\section{Comparison}

%=====================================================================
% \chapter{Discussion} \label{chp:discussion}
%=====================================================================

The results, both in terms of performance and ease of use, heavily favor Neo4j.
This is however expected, since we designed the queries in a way that favors a graph database in general.
We only used queries that apply to graph data structures to begin with, so Neo4j being the winner isn't that surprising after all.

However, the results also show that it is possible to use a relational database for simple graph queries.
Graph traversals can generally be simulated in SQL using two \lstinline{JOIN} statements.
This is less efficient than the $\rightarrow$ operator in Cypher, but it presents a viable solution if performance is not a big concern.

The area where SQL is insufficient in our view is for shortest path calculations.
A recursive query is already rather complex to understand to begin with, and we had to make a lot of weird changes to the first query to get it to run within an even remotely acceptable response time.
This is in stark contrast to the predefined \lstinline{shortest_path()} function in Cypher, which just worked out of the box with reasonable performance.

Whether to use Neo4j therefore depends on the actual requirements of the project.
If there are many queries that use shortest path or a form of subgraph matching, it might be worthwile to add Neo4j as an additional database.
The flip side is then of course that we have to handle the complexity and data integrity issues of maintaining two database management systems at the same time.

%=====================================================================
\chapter{Conclusion and future work} \label{chp:conclusion}
%=====================================================================

Graph databases are storage solutions which are optimized towards graph storage and processing.
They can efficiently perform calculations to traverse a graph or find a shortest path between two nodes.

In this report we have tried to find use cases where the graph database Neo4j might be used in addition to a relational database.
We analyzed five different queries on the graph from the ICIJ offshoreleaks papers and ran them in both databases.
In terms of performance, Neo4j executes most of these queries three to seven times faster than PostgreSQL.
The Cypher query language used by Neo4j is also generally easier to use thanks to the powerful graph traversal operator.

However, this does not mean that we wholeheartedly recommend Neo4j over Postgres.
The major flaw is that we specifically selected queries that operate on graph data, which is by its nature the strength of a graph database.
If the underlying data model is not a graph however, then the results of this report are not generally applicable.

We believe this resolves all remaining questions on this topic. No further research is needed \cite{xkcdresearch}.

\bibliographystyle{alpha}
\bibliography{references}
\end{document}
