\documentclass[11pt, a4paper,oneside,chapterprefix=false]{scrbook}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}

\usepackage{a4wide}
\usepackage{times}
\usepackage{helvet}   % sets sans serif font

\usepackage{amsmath,amssymb,amsthm}

\usepackage{graphicx}
\usepackage{subfigure}  
\usepackage{fancybox} % for shadowed or double bordered boxes
\usepackage{fancyhdr}
\usepackage{float}

\DeclareGraphicsExtensions{.pdf, .jpg}

%% macros
\input{include/math}
\input{include/codelisting_layout}

\usepackage{color}
\definecolor{RED}{rgb}{1,0,0}
\definecolor{GREEN}{rgb}{0,0.7,0}
\definecolor{BLUE}{rgb}{0,0,1}
\newcommand{\FIXME}[1]{{\color{RED}{\textbf{FIX}: #1}}}

\addtolength{\textheight}{2.0cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textwidth}{1.8cm}
\addtolength{\hoffset}{-.9cm}

\widowpenalty=10000
\clubpenalty=10000

%\author{Hans Muster}
%\title{Blockwise Hierarchical Data Decompositions}
%\date{Fall Semester 2011}

\begin{document}

\frontmatter
%\maketitle %automatic version
% --- selfmade version ----
\begin{titlepage}
	\setlength{\parindent}{0cm}
	\addtolength{\textheight}{1.0cm}
	\vspace{0.5cm}
	\sffamily\Huge
	{\textbf {CAS Report \\ A comparison of neo4j and postgres}}

	\vfill \vfill \vfill

	\vfill
	\textsf\Large
	CAS Data Science and Machine Learning \\[0.5cm]\large
	21.06.2022\\[0.5cm]
	\large
	by Roman Schmocker, Ergon Informatik AG

	\vfill \vfill \vfill
	\begin{minipage}[b]{0.5\textwidth}
	Supervisors: \\
	Prof. Dr. Sven Helmer
	\end{minipage}
	%
	\begin{minipage}[b]{0.5\textwidth} \raggedleft
	Department of Informatics \\
	University of Zurich
	\end{minipage}

	\vfill
	\hrule
	\vspace{0.5cm}
	\includegraphics*[width=0.3\textwidth]{figures/uzh_logo} \hfill
%	\includegraphics*[width=0.3\textwidth]{figures/vmml_logo}
\end{titlepage}
%%


%=====================================================================
\chapter{Abstract} \label{chp:abstract}
%=====================================================================


{\em Keywords}: TODO

\tableofcontents

\mainmatter

%=====================================================================
\chapter{Introduction} \label{chp:introduction}
%=====================================================================

Relational databases have been around for many years now and form a cornerstone of most modern IT applications.
In recent years however, NoSQL databases have gained more widespread use.
NoSQL databases renounce the table model and the underlying relational algebra of traditional database systems and instead provide alternative data storage solutions, each specialized to a specific task.

Graph databases are one such type of NoSQL databases.
They internally model all data as a graph, and as such are optimized towards graph traversal, path finding and visualizing relationships within graph structures.

A graph database might therefore be an ideal addition for the software project that we are working on at Ergon Informatik AG.
The goal of this project is to build a dossier management system for public prosecutors and the police.
A graph database could for example be used to visualize relations between different persons or to track the various paths that money has been paid to in a money laundering scheme.

In this report we will try to compare and find advantages of a graph database against relational databases.
We will pick PostgreSQL as a relational database, because it is a popular database that is already in use within our project.
For the graph database, we will use Neo4j - mostly because there are datasets readily available for our analysis.
As we already use PostgreSQL in our project, the goal of this analysis is not to decide whether to use one database system or the other, but rather to find out whether it is worthwile to add Neo4j in addition to PostgreSQL.
Therefore, all of the queries we analyze specifically target a scenario where the underlying model is already a graph, as we would otherwise simply use the already present PostgreSQL database.

%=====================================================================
\chapter{Database Systems} \label{chp:theory}
%=====================================================================

\section{PostgreSQL}
PostgreSQL \cite{postgres} is an open source that has been in development since 1996.
Its theoretical foundation is relational algebra \cite{relationalalgebra} and therefore represents a typical relational database system.
Data is stored in tables which can reference each other using foreign keys.
As opposed to most NoSQL solutions, there is a strict schema that data needs to conform to.
PostgreSQL uses SQL as a query language to filter and retrieve data from the database.

A graph can be stored within a relational database using a \lstinline{node} table that contains all nodes of the graph, as well as an \lstinline{edge} table with two forein key columns \lstinline{start_node} and \lstinline{end_node} which contains all edges of the graph.

\section{Neo4j}
Neo4j \cite{neo4j} is an open source graph database system with commercial support.
It has been in development since 2007.
As a graph database, Neo4j stores all its data as a labelled property graph - a graph composed of nodes and edges which both can have an arbitrary number of named properties.
Additionally, both nodes and edges can have a type (or label) which can be used to classify nodes and impose a semi-structured schema on the node regarding its properties.

For efficient graph traversal, Neo4j uses index-free adjacency internally \cite{neo4jinaction:chapter11}.
Index-free adjacency is a graph storage technique which allows to follow along graph edges simply by looking up a pointer in memory.
This is different from a relational database where a foreign key relation needs to be resolved by looking up the physical address of another entry via a database index and then loading the corresponding page table entry to memory in a second step.

The data in neo4j is queried through Cypher query language, an SQL-like language specifically desigend for graphs.
One of the main features of Cypher is the $(a)\rightarrow(b)$ operator, which is used to match against two nodes a and b connected by an edge.

%=====================================================================
\chapter{Methods} \label{chp:methods}
%=====================================================================


%---------------------------------------------------------------------
\section{The ICIJ offshoreleaks data set} \label{sec:dataset}
%---------------------------------------------------------------------

The dataset used for the comparison is from the ICIJ offshore leaks \cite{offshoreleaks}.
The ICIJ consortium provides the database as a dump file, and thus it can be directly imported to Neo4j.
The dataset is basically a huge graph which shows connections between letterbox companies (Entities) with their addresses, their board of owners and directors (Officers) as well as any intermediaries that provide legal services. In total the graph contains about  1.97 million nodes and 3.27 million edges.

To load the same dataset into a PostgresSQL database we used the ``Export as CSV'' function in Neo4J and then imported the resulting file into a temporary Postgres table using the \lstinline{COPY} statement.
As nodes and edges are mixed into a single table using this technique, we further copy the data into a \lstinline{node} and an \lstinline{edge} table with proper foreign key relations in between.
The type and labelled properties of the graph are mapped to individual columns in the database table.

Although it is possible to further partition the \lstinline{node} and \lstinline{edge} tables based on their labels, we decided against it to keep the flexibility of traversing the whole graph in SQL.

%---------------------------------------------------------------------
\section{Queries} \label{sec:benchmark}
%---------------------------------------------------------------------

For our comparison we select four queries as in \cite{graphdbbenchmark}.
In their paper they analyzed a simple point query to fetch just a single result, a one-hop and two-hop query to traverse along one or two edges respectively, and a shortest path query.
In addition to that we also add a slightly more complex query which is aimed towards finding a subgraph pattern within the whole graph.

Please note that - with the exception of the point query - all of our queries require some kind of graph traversal.
This kind of benchmark design heavily works in favor of Neo4j, which is designed to understand and operate on graphs data structures whereas Postgres only understands tables and relations.
But as already mentioned, the idea is not to pit one system against the other but rather to identify scenarios where a graph database is so much superior to a relational database that the integration of a second database management system might be justified.

\subsection{Point Query}

The point query is just a lookup of a graph node by its name property.
There should be no graph edge traversal necessary and therefore also no join in a relational database.

\begin{center}
\includegraphics*[width=0.175\textwidth]{figures/query-point.png}
\captionof{figure}{Example result of a point query}
\end{center}
\newpage
\subsection{One-Hop Query}

The one-hop query will search for a specific node by its name and look for any neighbors. It should return the found node as well as all directly adjacent nodes.

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query-one-hop.png}
\captionof{figure}{Example result of a one-hop query} \label{fig:two-hop}
\end{center}

\subsection{Two-Hop Query}

The two-hop query is similar to the one-hop query, but will also search for neighbors of neighbors of the start node and return them as well. 
It is important that these neighbors exist however, otherwise the result would be empty.
This can be by the address node ``Av. Santa Maria'' in Figure \ref{fig:two-hop}, which is present in the one-hop query but missing in the two-hop query result as it has no further neighbors on its own.

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query-two-hop.png}
\captionof{figure}{Example result of a two-hop query}
\end{center}

\subsection{Shortest Path}

The goal is to find the shortest path between two nodes, or if they are connected at all. In our example we want to find out if Marc Rich, the founder of Glencore who was later convicted for tax evasion and several other crimes, still has ties to the Glencore group.
The query should try to find a path regardless of the directionality of edges, which means travelling ``back'' along a directed edge is valid.
This allows us to identify a connection between letterbox companies which are registered to the same address.

\begin{center}
\includegraphics*[width=0.9\textwidth]{figures/query-shortest-path-2.png}
\captionof{figure}{Example result of a shortest path query}
\end{center}


\subsection{Subgraph Matching}

We want to find two different officers for the same company who live at the same address.
This query can for example be used to find family relations within the offshoreleaks dataset.

The type of query might be interesting because it requires the database to do pattern matching of a small subgraph structure against the whole graph.
We want to see if Neo4J has some tricks up its sleeve to faciliate the evaluation of these queries

\begin{center}
\includegraphics*[width=0.5\textwidth]{figures/query_relation.png}
\captionof{figure}{Example result of a subgraph matching query}
\end{center}



% \subsection{Transitive Query}
%
% Transitively find all nodes reachable from a start node, maybe up to some level X. E.g. find all entities that are directed by the king of Saudi Arabia [TODO: maybe find a better example]
%
% \includegraphics*[width=0.5\textwidth]{figures/query_transitive.png} \hfill


%---------------------------------------------------------------------
% \section{Measurements} \label{sec:measurements}
%---------------------------------------------------------------------



%=====================================================================
\chapter{Results} \label{chp:results}
%=====================================================================

\section{Performance}

For performance measurements, we repeatedly ran the above queries and measure average response time and standard deviation.
The simple queries are repeated 100 times.
The input for these queries varies each time with a different node to look for.
The shortest path and subgraph matching was repeated only 10 times with fixed input.
The measurement was done with Neo4J 4.4 and PostgreSQL 14.3, each running in a Docker container.
The host system has an AMD Ryzen 7 3700X CPU with 8 Cores and 32GB RAM.
The result of the measurements is shown in table \ref{table:performance}.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ |l|c|c|c| }
			\hline
			& no. of queries & neo4j & postgres \\
			\hline
			Point Query & 100 & 0.008 $\pm$ 0.016 & 0.002 $\pm$ 0.001 \\
			One-Hop & 100 & 0.006 $\pm$ 0.012 &  0.002 $\pm$ 0.003 \\
			Two-Hop & 100 & 0.009 $\pm$ 0.014 &  0.004 $\pm$ 0.003 \\
			Shortest Path & 10 & 2.638 $\pm$ 0.027 & 14.161 $\pm$ 0.113 \\
			Subgraph Matching & 10 & 5.360 $\pm$ 0.175 & 1.557 $\pm$ 0.225 \\
			\hline
		\end{tabular}
		\caption{\label{table:performance} Query exeuction time in seconds (mean $\pm$ standard deviation).}
	\end{center}
\end{table}

\section{Query complexity}

The following sections provide a side-by-side comparison of Cypher and SQL queries.

\subsection{Point Query} \label{sec:result:point}
\lstinputlisting[language=SQL,label=point-query]{pseudocode/point-query.txt}

\subsection{One-Hop Query}\label{sec:result:one-hop}
\lstinputlisting[language=SQL,label=one-hop-query]{pseudocode/one-hop.txt}

\subsection{Two-Hop Query} \label{sec:result:two-hop}
\lstinputlisting[language=SQL,label=two-hop-query]{pseudocode/two-hop.txt}

\subsection{Shortest Path} \label{sec:result:shortest-path}
\lstinputlisting[language=SQL,label=shortest-path-query]{pseudocode/shortest-path.txt}

\subsection{Subgraph Matching} \label{sec:result:subgraph-matching}
\lstinputlisting[language=SQL,label=subgraph-matching-query]{pseudocode/subgraph.txt}




%=====================================================================
\chapter{Discussion} \label{chp:Discussion}
%=====================================================================

\section{Performance}

Generally PostgreSQL performs better than Neo4j by a factor 2 to 4 in all but the shortest path query.
This is similar to the findings in \cite{graphdbbenchmark}, although the performance gap has become smaller.
The reason why PostgreSQL still performs much better than Neo4j might just be the overall maturity of the system.
Another reason could be that the queries were just not ``graph-heavy'' enough for Neo4j to really shine, with at most four edges considered in the subgraph matching query.

The one exception where Neo4j performs significantly better than PostgresSQL is in the shortest path query.
This is actually an interesting case in SQL as it was the only one where we first had to apply a few optimization to even get the query to run below one minute. For example, PostgreSQL always materializes a common table expression and does not push predicates into the CTE itself \cite{postgresMaterialize}.
Therefore it is imperative that the \lstinline{where} clause which selects the start node is within the recursive common table expression itself, or else PostgreSQL will happily calculate the shortest path from every node to every other node at once.
Another problem was that there can be multiple paths with the same length between two different nodes, and PostgreSQL would continue the search from both paths, leading to a lot of duplicate work. A \lstinline{select distinct on} operator can solve this problem however.
Both of these optimizations can be seen in the code listing in section \ref{sec:result:shortest-path}

Even with all these optimizations, Neo4j significantly outperforms PostgreSQL for shortest path calculations.
One possible explanation is that the former can apply specialized algorithms like Djikstra \cite{dijkstra} which are not easily doable in plain SQL. Neo4j also has the possibility to abort the query as soon as a viable solution has been found, whereas PostgreSQL will first fully evaluate its recursive common table expression and only then select a shortest path.

%---------------------------------------------------------------------
\section{Ease of use} \label{sec:convenience}
%---------------------------------------------------------------------

The graph traversal operator $(a) \rightarrow (b)$ offered by Neo4j is very powerful for reducing query complexity.
To achieve something similar in Postgres, every graph ``hop'' needs to be modeled as two joins between the node and edge table. The effect of this can be seen nicely in the two-hop query code in \ref{sec:result:two-hop}, which is only two $\rightarrow$ operators in Cypher but requires four joins in SQL. The net effect is only three lines of code for Cypher and almost 8 lines of code to achieve the same in SQL

Another useful query mechanism is the built-in \lstinline{shortest_path()} function in Cypher.
It is used to find connections between two nodes efficiently and with little write overhead.
To achieve the same functionality in in PostgreSQL we have to implement a kind of breadth-first search with a recursive common table expression and stop when the target node has been found.
The algorithm to perform this in SQL is shown in section \ref{sec:result:shortest-path}.
Here the difference in number of lines of code between Cypher and SQL is even more pronounced - there are only 5 lines of Cypher code but 28 lines of SQL code to calculate the shortest path between two nodes.

This example also nicely shows how Cypher can optionally ignore the directionality of an edge.
If we do not specify an arrowhead in the $\rightarrow$, Neo4j will just use any edge from or to a node to calculate the shortest path.
To achieve the same behavior in PostgreSQL we need to first calculate a union of the regular and reversed \lstinline{edge} table and perform all joins against this derived edge table.

Finally, in the last code listing in section \ref{sec:result:subgraph-matching} we can see the full power of the graph traversal operator. In the form \lstinline{(a:Officer) -[:officer_of]-> (entity:Entity)} it will match against a node of type \lstinline{Officer} with an \lstinline{officer_of} edge towards an \lstinline{Entity} node. An equivalent operation in SQL requires two joins and three \lstinline{WHERE} conditions.

\section{Comparison}
TODO: Section Ã¼berarbeiten
%=====================================================================
% \chapter{Discussion} \label{chp:PostgreSQL}
%=====================================================================

The results, both in terms of performance and ease of use, heavily favor Neo4j.
This is however expected, since we designed the queries in a way that favors a graph database in general.
We only used queries that apply to graph data structures to begin with, so Neo4j being the winner isn't that surprising after all.

However, the results also show that it is possible to use a relational database for simple graph queries.
Graph traversals can generally be simulated in SQL using two \lstinline{JOIN} statements.
This is less efficient than the $\rightarrow$ operator in Cypher, but it presents a viable solution if performance is not a big concern.

The area where SQL is insufficient in our view is for shortest path calculations.
A recursive query is already rather complex to understand to begin with, and we had to make a lot of weird changes to the first query to get it to run within an even remotely acceptable response time.
This is in stark contrast to the predefined \lstinline{shortest_path()} function in Cypher, which just worked out of the box with reasonable performance.

Whether to use Neo4j therefore depends on the actual requirements of the project.
If there are many queries that use shortest path or a form of subgraph matching, it might be worthwile to add Neo4j as an additional database.
The flip side is then of course that we have to handle the complexity and data integrity issues of maintaining two database management systems at the same time.

%=====================================================================
\chapter{Conclusion and future work} \label{chp:conclusion}
%=====================================================================

Graph databases are storage solutions which are optimized towards graph storage and processing.
They can efficiently perform calculations to traverse a graph or find a shortest path between two nodes.

In this report we have tried to find use cases where the graph database Neo4j might be used in addition to a relational database.
We analyzed five different queries on the graph from the ICIJ offshoreleaks papers and ran them in both databases.
In terms of performance, Neo4j executes most of these queries three to seven times faster than PostgreSQL.
The Cypher query language used by Neo4j is also generally easier to use thanks to the powerful graph traversal operator.

However, this does not mean that we wholeheartedly recommend Neo4j over Postgres.
The major flaw is that we specifically selected queries that operate on graph data, which is by its nature the strength of a graph database.
If the underlying data model is not a graph however, then the results of this report are not generally applicable.

TODO: reference new SQL standard

We believe this resolves all remaining questions on this topic. No further research is needed \cite{xkcdresearch}.

\bibliographystyle{alpha}
\bibliography{references}
\end{document}
