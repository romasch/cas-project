\documentclass[11pt, a4paper,oneside,chapterprefix=false]{scrbook}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}

\usepackage{a4wide}
\usepackage{times}
\usepackage{helvet}   % sets sans serif font

\usepackage{amsmath,amssymb,amsthm}

\usepackage{graphicx}
\usepackage{subfigure}  
\usepackage{fancybox} % for shadowed or double bordered boxes
\usepackage{fancyhdr}

\DeclareGraphicsExtensions{.pdf, .jpg}

%% macros
\input{include/math}
\input{include/codelisting_layout}

\usepackage{color}
\definecolor{RED}{rgb}{1,0,0}
\definecolor{GREEN}{rgb}{0,0.7,0}
\definecolor{BLUE}{rgb}{0,0,1}
\newcommand{\FIXME}[1]{{\color{RED}{\textbf{FIX}: #1}}}

\addtolength{\textheight}{2.0cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textwidth}{1.8cm}
\addtolength{\hoffset}{-.9cm}

\widowpenalty=10000
\clubpenalty=10000

%\author{Hans Muster}
%\title{Blockwise Hierarchical Data Decompositions}
%\date{Fall Semester 2011}

\begin{document}

\frontmatter
%\maketitle %automatic version
% --- selfmade version ----
\begin{titlepage}
	\setlength{\parindent}{0cm}
	\addtolength{\textheight}{1.0cm}
	\vspace{0.5cm}
	\sffamily\Huge
	{\textbf {CAS Report \\ A comparison of neo4j and postgres}}

	\vfill \vfill \vfill

	\vfill
	\textsf\Large
	CAS Data Science and Machine Learning \\[0.5cm]\large
	21.06.2022\\[0.5cm]
	\large
	by Roman Schmocker, Ergon Informatik AG

	\vfill \vfill \vfill
	\begin{minipage}[b]{0.5\textwidth}
	Supervisors: \\
	Prof. Dr. Sven Helmer
	\end{minipage}
	%
	\begin{minipage}[b]{0.5\textwidth} \raggedleft
	Department of Informatics \\
	University of Zurich
	\end{minipage}

	\vfill
	\hrule
	\vspace{0.5cm}
	\includegraphics*[width=0.3\textwidth]{figures/uzh_logo} \hfill
%	\includegraphics*[width=0.3\textwidth]{figures/vmml_logo}
\end{titlepage}
%%


%=====================================================================
\chapter{Abstract} \label{chp:abstract}
%=====================================================================


{\em Keywords}: TODO

\tableofcontents

\mainmatter

%=====================================================================
\chapter{Introduction} \label{chp:introduction}
%=====================================================================

Over many years the default for data storage was a relational database, and it still is today. 
However, in recent years the NoSQL Movement has gained traction.
NoSQL is actually an umbrella term for many different technologies.
Among them are graph databases.
Graph database optimize graph traversal and path finding and other stuff.
In this report, we want to look at a specific graph database Neo4j and compare it to Postgres, a popular free relational DB.

[TODO maybe also tell why neo4j might be used in our company]

%=====================================================================
\chapter{Database comparison (neo4j vs postgres)} \label{chp:theory}
%=====================================================================

On the relational side we have Postgres, a very classical relational database.
The underlying theory is relational algebra [link to paper].
Data is stored in tables with a strict schema.
The data can be queried using SQL.

Neo4j is a free graph database with commercial support.
Internally all data is stored as a labelled property graph.
Meaning there are nodes with properties, as well as edges with properties.
Internally, neo4j uses the index-free adjacency technique, a storage technique which allows to traverse a graph without looking up nodes in an index.
This is in contrast to relational database where foreign key relations have to be resolved by loading the specific entry from another table through an index.
The data in neo4j is queried through Cypher query language, an SQL like language specifically desigend for graphs.
It allows to match agains graph relations with the --> operator.

%=====================================================================
\chapter{Methods} \label{chp:methods}
%=====================================================================


%---------------------------------------------------------------------
\section{The ICIJ offshoreleaks data set} \label{sec:dataset}
%---------------------------------------------------------------------

The data used for the comparison is from the ICIJ offshoreleaks [link].
The consortium provides the database as a dump, and thus it can be directly imported to neo4j.

For postgres we use the export as CSV function.
This returns the data as one big table, which we can import using the postgres `COPY` statement to a temporary table.
Since nodes and edges are mixed using this technique, we further copy the data along with the relevant properties into a `node` and an `edge` table.
There are no further tables based on type because we want the flexibility of traversing the graph regardless of labels.
(On production systems we may want to have different tables per label or relationship type).

%---------------------------------------------------------------------
\section{Queries} \label{sec:benchmark}
%---------------------------------------------------------------------

There are three queries for the comparison. Note that queries focus a lot on graph traversal and give an advantage to neo4j. 
This is kind of fine, because we consider a scenario where a graph database is used in addition to a relational database.


\subsection{Subgraph Matching}

We want to find two different officers for the same firm who live at the same address, e.g. to find family relations.
This targets the subgraph matching [link?] aspect of graph databases.

\includegraphics*[width=0.5\textwidth]{figures/query_relation.png} \hfill

\subsection{Shortest Path}

Find the shortest path between two nodes, if they are connected at all. E.g. to find out if Marc Rich (former founder of Glencore and always a bit in trouble with the law) still has connections to the Glencore group.

\includegraphics*[width=0.5\textwidth]{figures/query_shortest_path.png} \hfill

\subsection{Transitive Query}

Transitively find all nodes reachable from a start node, maybe up to some level X. E.g. find all entities that are directed by the king of Saudi Arabia [TODO: maybe find a better example]

\includegraphics*[width=0.5\textwidth]{figures/query_transitive.png} \hfill


%---------------------------------------------------------------------
\section{Measurements} \label{sec:measurements}
%---------------------------------------------------------------------

We measure response time of a query
Average over 100 exeuctions (with different input?)
Postgres, neo4j in Docker Container. Maybe include hardware specs

%=====================================================================
\chapter{Results} \label{chp:results}
%=====================================================================


%---------------------------------------------------------------------
\section{Ease of use} \label{sec:convenience}
%---------------------------------------------------------------------

Shown here is a side by side comparison of query complexity:

TODO: add listings, maybe measure complexity somehow (num characters, num operators)?

Subgraph matching can be done with lots of joins.
Inconvenient, but possible.

There is no direct support for shortest path. 
We need to implement a BFS and stop when target node found.

The easy switch from directed to undirected path in neo4j is very powerful, needs a lot more fiddling around in Postgres.

Transitive queries are very similar in Postgres to the shortest path. In a way we actually calculate the 

%---------------------------------------------------------------------
\section{Performance} \label{sec:performance}
%---------------------------------------------------------------------

The result of the query performance is shown in table \ref{table:performance}:

\begin{table}
	\begin{center}
		\begin{tabular}{ |l|c|c|c| }
			\hline
			& queries & neo4j & postgres \\
			\hline
			Point Query & 100 & 0.043604s $\pm$ 0.021641s & 0.043645s $\pm$ 0.001029s \\
			One-Hop & 100 & 0.038591s $\pm$ 0.015960s & 0.121463s $\pm$ 0.005704s \\
			Two-Hop & 100 & 0.037369s $\pm$ 0.017822s & 0.275315s $\pm$ 0.007568s \\
			Shortest Path & 10& 2.531583s $\pm$ 0.034940s & 16.413803s $\pm$ 0.238791s \\
			Subgraph Matching & 10 & 5.521744s $\pm$ 0.155010s & 28.173800s $\pm$ 0.178777s \\
			\hline
		\end{tabular}
		\caption{\label{table:performance} Meaurement results (average $\pm$ standard deviation).}
	\end{center}
\end{table}


There were also some problems in Shortest Path to make it even remotely usable, e.g. Postgres materializes the with query (https://www.postgresql.org/docs/current/queries-with.html). Any where clause therefore needs to be pushed into the recursive query.
Another problem is that the intermediate result set gets too big if the distinct clause is not present (doubly calculated work).

%=====================================================================
\chapter{Discussion} \label{chp:discussion}
%=====================================================================

The result heavily favors neo4j, but this is expected since we chose queries where a graph DB is traditionally strong.
However, the result also shows that it is possible to use a relational database.
Whether to use neo4j or not (in addition to a relational DB) therefore very much depends on the requirements.
If there are many queries for subgraph matching or transitive graph traversal are required, the query improvements might outweigh the additional complexity and potential data duplication of having two database systems.

%=====================================================================
\chapter{Conclusion and future work} \label{chp:conclusion}
%=====================================================================

In this report we have analyzed three queries in neo4j and postgres and compared their execution performance and query complexity. 
Due to the design of the study, the result favors neo4j, but it depends on the requirements if neo4j should be used.
Note that this study does not try to answer the question if neo4j can be used instead of postgres, only if it can be used in addition to postgres. The former was never a goal.

We believe this resolves all remaining questions on this topic. No further research is needed. [https://xkcd.com/2268/]


\bibliographystyle{alpha}
\bibliography{references}
\end{document}
